from random import randint

class BoardException(Exception):
    pass

class BoardOutException(BoardException):        # Класс исключений для выстрела за пределы игрового поля (координата меньше 1 и более 6)
    def __str__(self):                          # Специальный метод строкового представления, чтобы избежать ссылки на ячейку памяти
        return "Вы пытаетесь выстрелить за пределы игрового поля! Повторите выстрел."

class DotRepeatException(BoardException):       # Класс исключений для повторного выстрела по ранее "обстреляной" клетке
    def __str__(self):                          # Специальный метод строкового представления
        return "В эту клетку раньше уже стреляли! Повторите выстрел."

# class AmountValueException(Exception):        # Класс исключений для ошибки ввода пользователем координат менее или более двух
   # pass

class BoardWrongShipException(Exception):       # Исключение, которое не будет выводить сообщение об ошибке
    pass

class Dot:                                      # Класс точек, определяемый параметрами
    def __init__(self, x, y):                   # Конструктор полей
        self.x = x                              # координата по оси ОХ
        self.y = y                              # координата по оси OY

    def __eq__(self, other):                                # Метод проверки точки на равенство координат
        return self.x is other.x and self.y is other.y      # с координатами других точек (экземпляров класса)

    #def __str__(self):                         # Специальный метод строкового представления объекта, чтобы избежать
     #   return f"Dot ({self.x}, {self.y})"     # вид "ссылка на ячейку памяти" при вызове объекта

    def __repr__(self):                         # Специальный метод представления, используется, в том числе
        return f"Dot ({self.x}, {self.y})"      # для вывода объектов в контейнере, типа списка


class Ship:                                     # Класс кораблей на игровом поле, описываемые параметрами:
    def __init__(self, length, x, y, direction):
        self.length = length                                # Длина корабля
        self.x = x                                          # Точка носа по оси ОХ
        self.y = y                                          # Точка носа по оси OY
        self.direction = direction                          # Направление. 0 - горизонтальное, 1 - вертикальное
        self.lives = length                                 # Количество жизней (изначально равно length)

    @property
    def dots(self):                     # Метод, который возвращает список точек корабля (список из списков [X, Y])
        position = []                   # Пустой список, для координат корабля
        position.append(Dot(self.x, self.y))
        if self.length == 1:                    # Если корабль одинарной длины, возвращается список с одной парой XY
            return position
        else:                                   # Если корабль длиннее 1, то в зависимости от .direction по циклу
            if self.direction == 0:             # добавляется единица к координате X или Y для следующей пары чисел
                for i in range(1,self.length):
                    position.append(Dot(self.x + i, self.y))
            else:
                for i in range(1,self.length):
                    position.append(Dot(self.x, self.y + i))
            return position

    def shooten(self, shot):                    # Метод проверки попадания "выстрела" (точки) в корабль (в одну из
        return shot in self.dots                # точек, занятых кораблем)


class Board:                                    # Класс игрового поля
    def __init__(self, hid=False, size=6):
        self.size = size                        # Атрибут размера стороны поля, по умолчанию 6
        self.hid = hid                          # Атрибут,"скрывающий" корабли от вывода на консоль

        self.count = 0                          # Количество пораженных кораблей

        self.field = [["O"] * size for _ in range(size)]    # Генератор списка. Формирует поле из нулей в
                                                            # виде списка списков
        self.busy = []                          # Список занятых точек, занятых кораблями, либо куда уже стреляли
        self.ships = []                         # Список кораблей. Создается при генерировании кораблей на доске

    def __str__(self):                          # Функция формирования специальной строки res, в которой хранится
        res = ""                                # вид доски, которую видит игрок, со всеми атрибутами (разделители,
        res += "  | 1 | 2 | 3 | 4 | 5 | 6 |"    # номера строк и столбцов, специальные символы переноса строки)
        for i, row in enumerate(self.field):
            res += f"\n{i + 1} | " + " | ".join(row) + " |"

        if self.hid:                            # Замена в строке res символов, если атрибут hid равен True
            res = res.replace("■", "O")
        return res

    def out(self, d):                           # Метод определяет, находится ли точка в пределах игрового поля
        return not ((0 <= d.x < self.size) and (0 <= d.y < self.size))  #

    def contour(self, ship, verb=False):        # Метод контура, для получения списка точек вокруг корабля
        near = [                                # Стандартный набор относительных сдвигов от каждой точки
            (-1, -1), (-1, 0), (-1, 1),         # корабля, во все стороны
            (0, -1), (0, 0), (0, 1),
            (1, -1), (1, 0), (1, 1)
        ]
        for d in ship.dots:                             # цикл перебора точек корабля
            for dx, dy in near:                         # из списка near извлекаются пары координат
                cur = Dot(d.x + dx, d.y + dy)           # и прибавляются к рассматриваемой точке корабля, сдвигая точку
                if not (self.out(cur)) and cur not in self.busy:    # Проверка двух условий
                    if verb:                            # Проверка параметра verd, (False по умолчанию), который определяет
                        self.field[cur.x][cur.y] = "."  # печать точки на поле, только в процессе игры!
                    self.busy.append(cur)               # Добавление новой точки (контурной) в список занятых точек

    def add_ship(self, ship):                           # Метод обавления корабля на доску
        for d in ship.dots:                                # Для точек корабля по циклу
            if self.out(d) or d in self.busy:              # Условие, что точка корабля внутри игр.поля и не в списке Busy
                raise BoardWrongShipException()            # Если условие True, выбрасывается исключение, без сообщения
        for d in ship.dots:
            self.field[d.x][d.y] = "■"
            self.busy.append(d)

        self.ships.append(ship)                         # Добавление списка своих кораблей
        self.contour(ship)                              # Обвод кораблей по контуру

    def shot(self, d):                                  # Метод "Выстрел"
        if self.out(d):                                 # Условие, что точка выстрела вышла за игровое поле
            raise BoardOutException()                   # Вызов класса исключения

        if d in self.busy:                              # Условие, что точка - не занята
            raise DotRepeatException()                  # Если занята, вызов класса исключения

        self.busy.append(d)                             # После проверки условий, добавление точки
                                                        # в список busy (занятых точек)
        for ship in self.ships:                         # Цикл с перебором кораблей
            if ship.shooten(d):                         # Вызов метода shooten класса ship
                ship.lives -= 1                         # Если True, уменьшаем количество жизней корабля
                self.field[d.x][d.y] = "X"              # и присваиваем точке поля знак "Х"
                if ship.lives == 0:                     # Если количество жизней корабля = 0,
                    self.count += 1                     # Увеличиваем количество пораженных кораблей на доске
                    self.contour(ship, verb=True)       # Делаем Контур корабля, что бы поставить вокруг "."
                    print("Корабль уничтожен!")         # Печать сообщения об уничтожении
                    return False                        # Возрат False, что бы дальше ход не делать
                else:                                   # Иначе (если кол-во жизней не = 0 )
                    print("Корабль ранен!")             # печать сообщения о ранении
                    return True                         # Возвращение True для повторения хода

        self.field[d.x][d.y] = "."                      # Если корабль не поражен, печать "точки"
        print("Мимо!")                                  # Вывод сообщения "Мимо"
        return False

    def begin(self):                                    # "Обнуление" списка busy
        self.busy = []

class Player:                                           # Создание класса "Игрок"
    def __init__(self, board, enemy):                   # Конструктор (магический)
        self.board = board                              # полей "Доска" и
        self.enemy = enemy                              # поля "своё - чужое" создаваемого класса

    def ask(self):
        raise NotImplementedError()                     # Стандартное исключение Python

    def move(self):                                     # Метод для бесконечного цикла попытки выстрела
        while True:
            try:                                        # Начало перехвата исключения
                target = self.ask()                     # Запрашиваем у AI или у пользователя координаты выстрела
                repeat = self.enemy.shot(target)        # Выполняется выстрел
                return repeat                           # Если выстрел успешен, то повтор
            except BoardException as e:                 # Если мимо доски или в точку busy, то выбрасывется
                print(e)                                # исключение и цикл повторяется


class AI(Player):                                       # Класс игрока компьютера, на основе класса Player
    def ask(self):                                      # Метод получения координат точки выстрела с использованием
        d = Dot(randint(0, 5), randint(0, 5))           # функции для получения случайных чисел в диапазоне
        print(f"Ход компьютера: {d.x + 1} {d.y + 1}")   # Вывод сообщения о ходе AI и координатах его выстрела
        return d


class User(Player):                                     # Класса игрока-человека на основе класса Player
    def ask(self):                                      # Метод опроса игрока пользователя для получения
        while True:                                     # двух координат
            cords = input("Ваш ход: ").split()          # Создание сообщения для ввода координат

            if len(cords) != 2:                         # Проверка, что длина списка координат равна 2-м
                print(" Введите 2 координаты! ")        # Если чисел больше или меньше 2, то опрос начинается
                continue                                # заново

            x, y = cords                                # присваивам введенные значения координатам Х и Y

            if not (x.isdigit()) or not (y.isdigit()):  # Проверяем, что введенные значения - это числа
                print(" Введите числа! ")
                continue

            x, y = int(x), int(y)                       # Делаем преобразование типа из str в int

            return Dot(x - 1, y - 1)                    # Функция возвращает координаты уменьшенные на 1
                                                        # т.к. индексы списков нумеруются от 0

class Game:                                             # Создание класса "игра"
    def __init__(self, size=6):                         # Конструктор игры
        self.size = size                                # Размер поля
        pl = self.random_board()                        # Создание экземпляра доски Пользователя
        co = self.random_board()                        # Создание экземпляра доски AI
        co.hid = True                                   # Для доски AI задается атрибут True для поля hid,
                                                        # что бы скрыть доску AI от пользователя
        self.ai = AI(co, pl)                            # Создаем игрока AI
        self.us = User(pl, co)                          # Создаем игрока Пользователь

    def try_board(self):                                # Функция генерации доски, заполненной кораблями
        lens = [3, 2, 2, 1, 1, 1, 1]                    # Список длин кораблей
        board = Board(size = self.size)                 # Создаем экземпляр Класса Доски, с размером из класса Board)
        attempts = 0                                    # Счетчик попыток
        for l in lens:                                  # Конечный цикл - по списку lens - длина кораблей
            while True:                                 # Вложенный бесконечный цикл
                attempts += 1                           # Добавление 1 к счетчику
                if attempts > 2000:                     # Проверка условия предельного значения счетчика
                    return None                         # Если не получается поставить корабли, функция возвращает None
                ship = Ship(l, randint(0, self.size), randint(0, self.size), randint(0,1))    # Задание атрибутов для экземпляра класса
                try:                                    # Начало блока try для перехвата возможного Исключения
                    board.add_ship(ship)                # Добавление корабля на доску
                    break                               # Прерывание цикла. Возврат к началу генерирования нового корабля
                except BoardWrongShipException:         # Если корабль не добавлен, выбрасывается исключение
                    pass                                # Исключение игнорируется без уведомления пользователя
        board.begin()                       # Метод в классе Board для обнуления списка busy
        return board                        # Возврат заполненной доски

    def random_board(self):                 # Функция генерирования доски исключающая появление экземпляра None
        board = None                        # для доски. Доска генерируется до тех пор, пока не будет сгенерирована
        while board is None:
            board = self.try_board()
        return board

    def greet(self):                         # Функция Приветствия
        print("-------------------")
        print("  Приветсвуем вас  ")
        print("      в игре       ")
        print("    морской бой    ")
        print("-------------------")
        print(" формат ввода: x y ")
        print(" x - номер строки  ")
        print(" y - номер столбца ")

    def loop(self):                             # Метод Игрового цикла
        num = 0                                 # Номер хода. Четный - ходит пользователь, нечетный - ходит AI
        while True:                             # Бесконечный цикл
            print("-" * 20)                     # Вывод в консоль ---------------------
            print("Доска пользователя:")        # Вывод в консоль: Доска пользователя:
            print(self.us.board)                # Генерация доски пользователя
            print("-" * 20)                     # Вывод в консоль ---------------------
            print("Доска компьютера:")          # Доска компьютера
            print(self.ai.board)                # Генерация доски компьютера
            print("-" * 20)                     # Вывод в консоль ---------------------
            if num % 2 == 0:                    # Проверка четности хода
                print("Ходит пользователь!")    # Вывод в консоль "Ходит пользователь"
                repeat = self.us.move()         # Вызов метода move (нужно ли повторить ход). Метод наследуется из класса Player
            else:
                print("Ходит компьютер!")       # Если номер хода не четный, ходит AI
                repeat = self.ai.move()         # Вызов метода move (нужно ли повторить ход). Метод наследуется из класса
            if repeat:                          # Если repeat == True
                num -= 1                        # Уменьшаем номер хода на единицу (ниже он увеличится на единицу и
                                                # пользователь или компьютер повторят ход на следующем цикле
            if self.ai.board.count == len(self.ai.board.ships):        # Проверка количества пораженных кораблей
                print("-" * 20)                 # Вывод в консоль ---------------------
                print("Пользователь выиграл!")  # Вывод в консоль "Пользователь выиграл"
                break                           # Прерывание цикла

            if self.us.board.count == len(self.us.board.ships):        # Проверка количества пораженных кораблей
                print("-" * 20)                 # Вывод в консоль ---------------------
                print("Компьютер выиграл!")     # Вывод в консоль "Пользователь выиграл"
                break                           # Прерывание цикла
            num += 1                            # Увеличение номера хода на 1

    def start(self):                            # Метод старта программы
        self.greet()                            # Вызов Метода Приветствия
        self.loop()                             # Вызов игрового цикла

g = Game()
g.start()
